Mini Manual: Construcción del Daemon en Go (El Monitor)1. El ObjetivoEl Daemon es un programa en Espacio de Usuario encargado de orquestar todo el sistema. Su función es leer los datos "crudos" del Kernel, interpretarlos, cruzarlos con Docker y tomar decisiones (eliminar contenedores) y guardar evidencias (Base de datos).2. Preparación del EntornoPara que el código funcione, se configuraron las siguientes dependencias:Inicialización del Módulo:go mod init daemonEsto crea el archivo go.mod para gestionar librerías.Driver de Base de Datos:go get github.com/mattn/go-sqlite3Necesario para que Go pueda hablar con SQLite. Requiere tener gcc instalado en el sistema porque usa CGO.3. Lógica de Programación (Paso a Paso)El programa no es lineal, es un Ciclo Infinito que se repite cada 5 segundos. Aquí explicamos qué hace en cada vuelta:A. Detección de Docker (getDockerContainers)Qué hace: Ejecuta el comando de terminal docker ps --format ....Por qué: El Kernel solo nos da PIDs (números), pero no sabe si esos procesos son contenedores de Docker ni cómo se llaman.Técnica: Usamos la librería os/exec para correr comandos de bash desde Go.Manejo de Errores: Se agregó validación para avisar si faltan permisos (sudo).B. Lectura del Kernel (readKernelProcs)Qué hace: Lee el archivo /proc/continfo_so1_... generado por tu módulo C.Técnica: Usa os.ReadFile para obtener el contenido completo y json.Unmarshal para convertir ese texto JSON en una estructura (struct) de Go manipulable.C. Cálculo de CPU (calculateCPU)El Problema: El Kernel entrega "ticks totales desde que inició el proceso" (utime + stime), no un porcentaje actual.La Solución: Aplicamos cálculo diferencial.$$CPU = \frac{(\text{TiempoTotal}_{Actual} - \text{TiempoTotal}_{Anterior})}{\text{Tiempo Transcurrido (segundos)} \times 100 \text{ Hz}} \times 100$$Memoria: Usamos un mapa global (var history) para recordar cuánto tiempo de CPU tenía el proceso hace 5 segundos y poder hacer la resta.D. Persistencia (insertLog)Qué hace: Guarda una "foto" del estado actual en el archivo metrics.db.Tecnología: SQLite3.Query: INSERT INTO logs (timestamp, pid, name, ram, cpu) VALUES (...).E. Lógica "Thanos" (Control de Procesos)Configuración: Se definieron constantes:DESIRED_HIGH = 2DESIRED_LOW = 3Acción:Cuenta cuántos procesos de tipo "stress" (Alto) y "sleep" (Bajo) hay.Si Conteo > Deseado, calcula la diferencia (ej. sobran 2).Llama a killContainers que ejecuta kill -9 PID sobre los procesos sobrantes.4. Estructura de Archivos del Daemonmain.go: Contiene toda la lógica (Lectura, Cálculo, Base de Datos).go.mod: Define el nombre del módulo y la versión de Go.go.sum: Checksum de seguridad para la librería de SQLite.metrics.db: (Generado automáticamente) El archivo de base de datos resultante.5. Comandos de EjecuciónPara correr este daemon, es obligatorio usar permisos de superusuario debido a que necesita acceder al socket de Docker y enviar señales de kill a otros procesos.Bash# Opción 1: Ejecutar directamente (Desarrollo)
# "env PATH=$PATH" es un truco para que sudo encuentre el comando 'go'
sudo env "PATH=$PATH" go run main.go

# Opción 2: Compilar y ejecutar (Producción/Entrega)
go build -o monitor
sudo ./monitor
Este resumen cubre todo lo técnico que hiciste en la Fase 3. ¿Te sirve así o quieres que profundice en alguna función específica?